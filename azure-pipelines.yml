trigger:
  - master

resources:
  - repo: self

variables:
  # Go
  GOVERSION: '1.13'
  GOROOT: '/usr/local/go$(GOVERSION)'
  GOPATH: '/home/vsts/go'

  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'a041da97-3f29-4781-a417-751b98eb7903'
  imageRepository: 'italypaleale/smplatform'
  containerRegistry: 'hub.docker.com'
  dockerfilePath: '$(Build.SourcesDirectory)/container/Dockerfile'
  dockerTag: '$(Build.BuildNumber)'
  testDockerfilePath: '$(Build.SourcesDirectory)/e2e-test/Dockerfile'
  coverageDockerfilePath: '$(Build.SourcesDirectory)/e2e-test/Dockerfile-coverage'
  testImageRepository: 'smplatform-test'

# TODO: Switch to pipeline artifacts, then on non-build stages do not check out source code anymore (checkout: none)

stages:
  - stage: build
    displayName: Build SMPlatform artifacts
    jobs:
      - job: build
        displayName: Build artifacts for Linux (amd64, arm64, armhf)
        pool:
          vmImage: ubuntu-18.04
        steps:
          # Set up go environment
          - bash: |
              set -e

              # Add to GOBIN to PATH
              echo '##vso[task.prependpath]$(GOBIN)'
              echo '##vso[task.prependpath]$(GOROOT)/bin'
            displayName: "Set up go environment"
          # Build amd64
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$BUILD_TIME -X smplatform/buildinfo.CommitHash=$COMMIT_HASH" \
                  -o bin/smplatform_linux_amd64
            displayName: "Build amd64"
          # Build amd64 with coverage
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
                go test \
                  -coverpkg=smplatform/... \
                  -c \
                  -tags e2etests \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$BUILD_TIME -X smplatform/buildinfo.CommitHash=$COMMIT_HASH" \
                  -o bin/smplatform_linux_amd64.test
            displayName: "Build amd64 with coverage"
          # Build arm64
          # Only run on master
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
              GOOS=linux \
              GOARCH=arm64 \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$BUILD_TIME -X smplatform/buildinfo.CommitHash=$COMMIT_HASH" \
                  -o bin/smplatform_linux_arm64
            displayName: "Build arm64"
            condition: "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))"
          # Build armhf
          # Only run on master
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
              GOOS=linux \
              GOARCH=arm \
              GOARM=7 \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$BUILD_TIME -X smplatform/buildinfo.CommitHash=$COMMIT_HASH" \
                  -o bin/smplatform_linux_armhf
            displayName: "Build armhf"
            condition: "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))"
          # Copy binaries to the artifacts staging directory
          - task: CopyFiles@2
            displayName: Copy binaries to the artifacts staging directory
            inputs:
              sourceFolder: 'bin/'
              contents: '**/*'
              targetFolder: '$(Build.ArtifactStagingDirectory)'
          # Publish binaries as artifacts
          - task: PublishBuildArtifacts@1
            displayName: 'Publish build artifacts'
            inputs:
              artifactName: drop
  
  # Build Docker container and run tests for amd64
  - stage: docker
    displayName: Containerize and test
    dependsOn: build
    jobs:
      - job: docker
        displayName: Containerize and test
        pool: 
          vmImage: ubuntu-18.04
        steps:
          # Download build artifacts from previous stage
          - task: DownloadBuildArtifacts@0
            displayName: Download build artifacts
            inputs:
              buildType: current
              artifactName: drop
              downloadPath: '$(Build.ArtifactStagingDirectory)'
          # Copy binaries from the artifacts staging directory
          - task: CopyFiles@2
            displayName: Copy binaries from the artifacts staging directory
            inputs:
              sourceFolder: '$(Build.ArtifactStagingDirectory)/drop'
              contents: '**/*'
              targetFolder: 'bin/'
          # Build Docker image
          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              buildContext: $(Build.SourcesDirectory)
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                latest
          # Build Docker test image with coverage
          - bash: |
              set -e
              mkdir e2e-test/bin
              cp bin/*.test e2e-test/bin
              docker build \
                -f $(coverageDockerfilePath) \
                -t $(testImageRepository) \
                $(Build.SourcesDirectory)/e2e-test
            displayName: Build Docker test image with coverage
          # Run end-to-end tests
          - bash: |
              set -e
              docker run \
                --rm \
                -v $(pwd)/e2e-test/container_etc:/etc/smplatform \
                -v $(pwd)/e2e-test/results:/results \
                -e "AZURE_STORAGE_KEY=$(AZURE_STORAGE_KEY)" \
                -e "AZURE_CLIENT_SECRET=$(AZURE_CLIENT_SECRET)" \
                -e "NODE_URL=smplatform.local:2265" \
                -e "NGINX_URL=smplatform.local" \
                --add-host "smplatform.local:127.0.0.1" \
                $(testImageRepository)
            displayName:  Run end-to-end tests
          # Publish test results
          - task: PublishTestResults@2
            displayName: Publish test results
            inputs:
              testRunner: JUnit
              testResultsFiles: e2e-test/results/*.xml
          # Get coverage tools
          - task: UniversalPackages@0
            inputs:
              command: download
              downloadDirectory: $(System.DefaultWorkingDirectory)/bin/
              vstsFeed: go-binaries
              vstsFeedPackage: 'coverage-linux-amd64'
              vstsPackageVersion: 1.0.0
            displayName: Get coverage tools
          # Convert coverage results
          - bash: |
              set -e
              chmod +x ./bin/gocov*
              sudo chmod 0777 e2e-test/results
              sudo chmod 0666 e2e-test/results/*
              ./bin/gocov convert e2e-test/results/coverage.out | ./bin/gocov-xml > e2e-test/results/coverage.xml
            displayName: Convert coverage results
          # Publish coverage results
          - task: PublishCodeCoverageResults@1
            inputs: 
              codeCoverageTool: Cobertura
              summaryFileLocation: $(Build.SourcesDirectory)/e2e-test/results/coverage.xml
            displayName: Publish coverage results
          # Push Docker image to container registry
          # Only run on master
          - task: Docker@2
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
            displayName: Push Docker image to container registry
            inputs:
              command: push
              repository: $(imageRepository)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                latest
          # Post-build cleanup
          - bash: |
              # Delete files from disk
              sudo rm -rvf $(Agent.BuildDirectory) || true
              sudo rm -rvf $(Build.SourcesDirectory) || true
              sudo rm -rvf $(Build.ArtifactStagingDirectory) || true
              # Remove Docker images
              docker rmi -f $(docker images -q) || true
            displayName: "Post-build cleanup"
            # This step always runs, even if the pipeline failed
            condition: always()
