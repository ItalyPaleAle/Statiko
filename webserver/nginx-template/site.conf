# TLS-enabled website
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    # Listen on the domain
    server_name {{.Item.Domain}};

    # Configure logging
    access_log off;
    error_log {{.AppRoot}}sites/{{.Item.Domain}}/nginx-error.log error;

    # TLS
    ssl_certificate {{.AppRoot}}sites/{{.Item.Domain}}/tls/certificate.pem;
    ssl_certificate_key {{.AppRoot}}sites/{{.Item.Domain}}/tls/key.pem;
    ssl_dhparam {{.TLS.Dhparams}};

    # Webroot
    root {{.AppRoot}}sites/{{.Item.Domain}}/www;
    index index.html index.htm;

    # Error pages
    {{if not (eq .Item.App.Manifest.Page404 "")}}
        error_page 404 /{{.Item.App.Manifest.Page404}};
    {{end}}
    location / {
        try_files $uri $uri/ =404;
        {{if and .Item.App.Manifest.Locations (index .Item.App.Manifest.Locations "/") }}
            {{$v := (index .Item.App.Manifest.Locations "/")}}
            {{if and (not (eq $v.ClientCaching "")) (not (eq $v.ClientCaching "0"))}}
                expires "{{$v.ClientCaching}}";
                add_header Pragma public;
                add_header Cache-Control "public";
            {{end}}

            {{range $hk, $hv := $v.CleanHeaders}}
                add_header "{{$hk}}" "{{$hv}}";
            {{end}}
        {{end}}
    }
    {{if not (eq .Item.App.Manifest.Page403 "")}}
        error_page 403 /{{.Item.App.Manifest.Page403}};
    {{end}}

    # Rules for specific files
    {{range $k, $v := .Item.App.Manifest.Files}}
        {{if eq $k "_images"}}
            location ~* \.(jpg|jpeg|png|gif|ico|svg|svgz|webp|tif|tiff|dng|psd|heif|bmp)$ {
        {{else if eq $k "_videos"}}
            location ~* \.(mp4|m4v|mkv|webm|avi|mpg|mpeg|ogg|wmv|flv|mov)$ {
        {{else if eq $k "_audios"}}
            location ~* \.(mp3|mp4|aac|m4a|flac|wav|ogg|wma)$ {
        {{else if eq $k "_fonts"}}
            location ~* \.(woff|woff2|eot|otf|ttf)$ {
        {{else}}
            location ~* \.({{$k}})$ {
        {{end}}

            {{if and (not (eq $v.ClientCaching "")) (not (eq $v.ClientCaching "0"))}}
                expires "{{$v.ClientCaching}}";
                add_header Pragma public;
                add_header Cache-Control "public";
            {{end}}

            {{range $hk, $hv := $v.CleanHeaders}}
                add_header "{{$hk}}" "{{$hv}}";
            {{end}}
        }
    {{end}}

    # Rules for specific locations
    {{range $k, $v := .Item.App.Manifest.Locations}}
        {{if not (eq $k "/")}}
            location {{$k}} {
                {{if and (not (eq $v.ClientCaching "")) (not (eq $v.ClientCaching "0"))}}
                    expires "{{$v.ClientCaching}}";
                    add_header Pragma public;
                    add_header Cache-Control "public";
                {{end}}

                {{range $hk, $hv := $v.CleanHeaders}}
                    add_header "{{$hk}}" "{{$hv}}";
                {{end}}
            }
        {{end}}
    {{end}}

    # Block access to the manifest file
    location = /{{.ManifestFile}} {
        return 404;
    }

    # Rewrites
    {{range $k, $v := .Item.App.Manifest.Rewrite}}
        rewrite {{$k}} {{$v}} last;
    {{end}}
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    listen [::]:80;

    # Listen on the domain and on the aliases if any
    server_name {{.Item.Domain}} {{if .Item.Aliases}}{{joinList .Item.Aliases " "}}{{end}};

    # Configure logging
    access_log off;
    error_log {{.AppRoot}}sites/{{.Item.Domain}}/nginx-error.log error;

    # Redirect to the HTTPS website
    return 301 https://{{.Item.Domain}}$request_uri;
}

{{if .Item.Aliases}}
# Redirect aliases (on HTTPS) to the canonical host
server {
    listen [::]:443 ssl http2;
    listen 443 ssl http2;

    # Listen on the wrong hosts
    server_name {{joinList .Item.Aliases " "}};

    # Configure logging
    access_log off;
    error_log {{.AppRoot}}sites/{{.Item.Domain}}/nginx-error.log error;

    # TLS
    ssl_certificate {{.AppRoot}}sites/{{.Item.Domain}}/tls/certificate.pem;
    ssl_certificate_key {{.AppRoot}}sites/{{.Item.Domain}}/tls/key.pem;
    ssl_dhparam {{.TLS.Dhparams}};

    # Redirect to the canonical host
    return 301 https://{{.Item.Domain}}$request_uri;
}
{{end}}
